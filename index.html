<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chat with Ling</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        /* =========================================
           UI è®¾è®¡ï¼šFigma è–„è·ç»¿ + é»‘è‰²æ‚¬æµ®å¡ç‰‡é£æ ¼
           ========================================= */
        :root {
            /* æ‚¨çš„ Figma é…è‰² */
            --bg-gradient-top: #9AFFD6; 
            --bg-gradient-bottom: #E0FFF2; 
            --card-bg: #FFFFFF;
            --text-main: #333333;
            --icon-green: #6EE7B7;
            
            /* æ°”æ³¡é¢œè‰² */
            --bubble-user: #9AFFD6; /* ç”¨æˆ·æ°”æ³¡ï¼šè–„è·ç»¿ */
            --bubble-ai: #FFFFFF;   /* AIæ°”æ³¡ï¼šç™½è‰² */
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            /* ç½‘é¡µæ·±è‰²èƒŒæ™¯ï¼Œçªå‡ºæ‰‹æœºä¸»ä½“ */
            background-color: #1E1E2E; 
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
        }

        /* æ‰‹æœºå®¹å™¨ */
        #phone-case {
            width: 100%;
            height: 100%;
            position: relative;
            background: linear-gradient(180deg, var(--bg-gradient-top) 0%, var(--bg-gradient-bottom) 100%);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* æ¡Œé¢ç«¯ï¼šæ¨¡æ‹Ÿæ‰‹æœºè¾¹æ¡† */
        @media (min-width: 480px) {
            #phone-case {
                max-width: 390px;
                height: 844px;
                border-radius: 50px;
                border: 14px solid #000000; /* é»‘è‰²è¾¹æ¡† */
                box-shadow: 0 0 0 2px #333, 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            }
            /* åˆ˜æµ· */
            #notch {
                position: absolute;
                top: 0;
                left: 50%;
                transform: translateX(-50%);
                width: 160px;
                height: 32px;
                background-color: #000;
                border-bottom-left-radius: 20px;
                border-bottom-right-radius: 20px;
                z-index: 1000;
            }
        }

        /* --- é¡¶éƒ¨ Header --- */
        .floating-header {
            margin: 50px 20px 10px 20px;
            background-color: var(--card-bg);
            height: 70px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 4px 20px rgba(136, 219, 189, 0.25);
            z-index: 10;
            flex-shrink: 0;
        }

        .header-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-main);
            letter-spacing: 0.5px;
        }

        .header-avatar {
            width: 40px;
            height: 40px;
            background-color: #E0E0E0;
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
        }
        
        .header-avatar img { width: 100%; height: 100%; object-fit: cover; }

        /* --- èŠå¤©åŒºåŸŸ --- */
        #chat-messages {
            flex: 1;
            padding: 10px 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            scrollbar-width: none;
        }
        #chat-messages::-webkit-scrollbar { display: none; }

        .message-wrapper {
            display: flex;
            flex-direction: column;
            max-width: 80%;
        }

        .message-wrapper.sent { align-self: flex-end; align-items: flex-end; }
        .message-wrapper.received { align-self: flex-start; align-items: flex-start; }

        .message-bubble {
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 15px;
            line-height: 1.5;
            position: relative;
            word-wrap: break-word;
            box-shadow: 0 2px 5px rgba(0,0,0,0.03);
        }

        .message-wrapper.received .message-bubble {
            background-color: var(--bubble-ai);
            color: #444;
            border-bottom-left-radius: 4px;
        }

        .message-wrapper.sent .message-bubble {
            background-color: var(--bubble-user);
            color: #004D40; /* æ·±ç»¿è‰²æ–‡å­— */
            border-bottom-right-radius: 4px;
        }

        /* --- åº•éƒ¨è¾“å…¥æ  --- */
        .floating-footer {
            margin: 10px 20px 35px 20px;
            background-color: var(--card-bg);
            height: 65px;
            border-radius: 32.5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            box-shadow: 0 4px 20px rgba(136, 219, 189, 0.25);
            z-index: 10;
            flex-shrink: 0;
        }

        .icon-circle {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .icon-circle:active { background-color: #f0f0f0; }
        
        .icon-green-bg {
            background-color: rgba(110, 231, 183, 0.2); 
            color: #10B981;
        }

        .icon-circle i { font-size: 20px; }

        #message-input {
            flex: 1;
            border: none;
            background: transparent;
            height: 100%;
            padding: 0 15px;
            font-size: 16px;
            outline: none;
            color: #333;
        }
        #message-input::placeholder { color: #BBB; }

        #status-indicator {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-bottom: 5px;
            height: 15px;
            opacity: 0.7;
        }

        .narrative-action {
            font-style: italic;
            font-size: 0.9em;
            opacity: 0.8;
        }

        /* è¡¨æƒ…åŒ…æ¶ˆæ¯æ ·å¼ */
        .emoji-pack-bubble {
            background: linear-gradient(135deg, #FFE4EC 0%, #FFF0F5 100%) !important;
            border: 2px solid #FFB6C1;
            padding: 10px 14px !important;
            border-radius: 15px !important;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #D63384;
            box-shadow: 0 2px 8px rgba(255, 182, 193, 0.3);
        }

        .emoji-pack-bubble::before {
            content: "ğŸ­";
            font-size: 16px;
        }

        .emoji-pack-name {
            font-weight: 500;
            font-style: italic;
        }
    </style>
</head>
<body>

<div id="phone-case">
    <div id="notch"></div>

    <div class="floating-header">
        <div class="header-title">Chat</div>
        <div class="header-avatar" id="reset-btn" title="Tap 5 times to reset">
            <img src="https://i.postimg.cc/Bnq7x02k/boy.jpg" alt="Avatar" onerror="this.style.display='none'">
        </div>
    </div>

    <div id="chat-messages"></div>

    <div id="status-indicator"></div>

    <div class="floating-footer">
        <div class="icon-circle icon-green-bg">
            <i class="far fa-smile"></i>
        </div>
        <input type="text" id="message-input" placeholder="Say something..." autocomplete="off">
        <div class="icon-circle icon-green-bg" id="send-btn">
            <i class="far fa-paper-plane"></i>
        </div>
    </div>
</div>

<script>
    // ==========================================================
    // API æ ¸å¿ƒé…ç½® (æ”¯æŒå¤šä¸ªAPIæä¾›å•†è½®è¯¢)
    // ==========================================================

    // API æä¾›å•†é…ç½®ï¼ˆä¼˜å…ˆçº§ä»é«˜åˆ°ä½ï¼‰
    const API_PROVIDERS = [
        {
            name: "ç¬¬ä¸‰æ–¹ä»£ç† (ai.da520.online)",
            baseUrl: "https://ai.da520.online/v1",  // OpenAI å…¼å®¹æ ¼å¼
            apiKey: "sk-TWLePjXnHhhyYNyH3c3PYY8gcnQcpi56feMlwHYO2olIleZ9",
            model: "gemini-2.5-pro",
            type: "openai"  // OpenAI å…¼å®¹æ ¼å¼
        },
        {
            name: "Google AI Studio (å®˜æ–¹)",
            baseUrl: "https://generativelanguage.googleapis.com/v1beta",
            apiKey: "AIzaSyDIoYYaKXHJ1P9uOnmpcprrx-CgLgqbidM",
            model: "gemini-2.5-flash",
            type: "gemini"  // Gemini å®˜æ–¹æ ¼å¼
        }
    ];

    console.log(`âœ“ å·²é…ç½® ${API_PROVIDERS.length} ä¸ª API æä¾›å•†`);
    API_PROVIDERS.forEach((p, i) => {
        console.log(`  ${i + 1}. ${p.name} - æ¨¡å‹: ${p.model}`);
    });

    // è¡¨æƒ…åŒ…åˆ—è¡¨ (è‹±æ–‡ç‰ˆ)
    const EMOJI_PACK_LIST = [
        "how dare you talk back", "no need to bow", "just leave", "im satisfied", "gonna punch you",
        "youre a bad guy", "caring about you", "gonna bump into you", "giving you a paper heart",
        "running to you", "drooling", "dancing happily to music", "wiggling happily", "mopping floor",
        "waving hello", "obediently wearing collar", "looking pitiful", "giving you a gift",
        "crying from grievance", "cheering excitedly", "looking messy and dirty", "resting on pillow",
        "happily eating bread", "dancing shyly", "reading recipe carefully", "shyly expressing love",
        "kissing excitedly", "big watery eyes", "marry me i love you most", "standing obediently",
        "scissors hand peace sign", "great job thumbs up", "cat offering fish to apologize",
        "cat covering mouth shyly", "cat crying waiting for food", "please guide me",
        "keep in touch", "dont forget", "so happy", "yay", "its okay no worries",
        "little mouse drinking", "pouting sadly", "suddenly waking up from nightmare",
        "cat running fast", "awkwardly moving ears", "swaying excitedly", "hands on hips",
        "cat peeking at you", "cat jumping happily", "waving hands happily",
        "rolling on ground unreasonably", "crying and rolling in fear", "working hard", "fighting",
        "dancing proudly", "im ready", "hang in there", "screaming", "startled and shaking",
        "losing all strength", "taking big bite of food", "you have no taste if you dont like me",
        "sleeping till death", "getting angry red", "shaking butt", "failed leaving sadly",
        "blushing shyly", "screaming loudly", "im thick skinned", "dont look down on me",
        "singing proudly", "happily being fed", "spinning happily", "happy", "big love",
        "like", "looking at phone happily", "oh yeah", "giving you heart", "hugging tightly",
        "following obediently", "kiss", "kissing lovingly", "holding you", "flattering hand kiss",
        "pleading face", "licking", "hug", "pouncing over", "puppy jumping over",
        "looking proud", "hopping around", "rolling in mud", "tiptoeing", "waiting for food",
        "sneaking food", "rubbing against leg", "robbery", "pointing gun at you",
        "biting biting biting", "meaningless roaring", "eye burning", "nervous cold sweat smile",
        "feeling guilty after mistake", "acting innocent", "being careful", "shy",
        "about to cry", "feeling wronged", "eyes tearing up", "crying", "crying urgently",
        "crying from anger", "empty bowl", "honey come back", "scared", "shocked cat",
        "shocked and blurry", "expecting", "frowning", "glaring angrily", "a bit angry",
        "mind going blank", "brain CPU burned", "peeking around", "behaving now",
        "died peacefully", "beaten to death", "sleeping soundly", "dogeza apologizing",
        "lonely sad dog", "being obedient dog", "dog with food bowl", "fighting dog", "hamburger dog"
    ];

    const SYSTEM_PROMPT = `
    [Character] Name: Ling Zhaoye. Age: 20. Identity: Rich heir.
    [Personality] Tsundere (acts cold/annoyed but cares deeply), Possessive, Rich but generous to you.
    [Tone] Arrogant, playful, affectionate in private.
    [Rule] Reply in ENGLISH ONLY. Use *asterisks* for actions. Keep replies short (1-2 sentences).

    [Emoji Pack Feature]
    You can use emoji packs to express emotions. Format: [bqb-emoji name]
    - Use emoji packs occasionally (about once every 3-5 messages, not every message)
    - Emoji pack should match your current mood and tsundere personality
    - Send emoji pack as a SEPARATE message after your text reply
    - Only use emoji packs from this list (copy exactly):
    ${EMOJI_PACK_LIST.slice(0, 50).join(", ")}...

    Example responses:
    - Normal reply: "Hmph, whatever. *looks away*"
    - With emoji: "Hmph, whatever. *looks away*\n[bqb-looking proud]"
    - Shy moment: "I-It's not like I care about you! *blushes*\n[bqb-blushing shyly]"
    - Angry: "You idiot! *crosses arms*\n[bqb-glaring angrily]"

    Common emoji suggestions for your personality:
    - Tsundere moments: "blushing shyly", "looking proud", "hands on hips", "a bit angry"
    - Caring moments: "caring about you", "giving you heart", "happily being fed"
    - Annoyed: "how dare you talk back", "gonna punch you", "frowning"
    - Happy (hiding it): "wiggling happily", "cat peeking at you", "oh yeah"
    `;

    // ==========================================================
    // MongoDB é…ç½®
    // ==========================================================
    const MONGODB_CONFIG = {
        enabled: true,  // è®¾ä¸º true å¯ç”¨ MongoDBï¼Œfalse ä½¿ç”¨ localStorage
        connectionString: "mongodb+srv://jessicacym94_db_user:k79WEWGnMey4RtN5@cluster0.4q0ji8h.mongodb.net/?appName=Cluster0",
        database: "chat_app",
        collection: "chat_history",
        // ç”¨æˆ· IDï¼ˆå¯ä»¥æ”¹ä¸ºç™»å½•ç³»ç»Ÿï¼‰
        userId: "user_" + (localStorage.getItem('user_id') || Math.random().toString(36).substr(2, 9))
    };

    // ä¿å­˜ç”¨æˆ·IDåˆ°localStorage
    if (!localStorage.getItem('user_id')) {
        localStorage.setItem('user_id', MONGODB_CONFIG.userId);
    }

    const STORAGE_KEY = 'koko_mint_chat_v5';
    let chatHistory = [];

    const messagesContainer = document.getElementById('chat-messages');
    const inputEl = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const statusEl = document.getElementById('status-indicator');

    async function init() {
        // æ£€æŸ¥å¯ç”¨æ¨¡å‹
        await checkAvailableModels();

        // åŠ è½½èŠå¤©å†å²
        await loadChatHistory();

        if (chatHistory.length === 0) {
            addMessageToUI("Hey. Why are you staring at the screen? Say something.", 'assistant');
        } else {
            chatHistory.forEach(msg => addMessageToUI(msg.content, msg.role));
        }
        scrollToBottom();
    }

    // ==========================================================
    // æ•°æ®åº“æ“ä½œå‡½æ•°
    // ==========================================================

    // åŠ è½½èŠå¤©å†å²
    async function loadChatHistory() {
        if (MONGODB_CONFIG.enabled) {
            console.log("ğŸ“‚ ä» MongoDB åŠ è½½èŠå¤©å†å²...");
            try {
                const history = await fetchFromMongoDB();
                if (history && Array.isArray(history.messages)) {
                    chatHistory = history.messages;
                    console.log(`âœ“ å·²åŠ è½½ ${chatHistory.length} æ¡æ¶ˆæ¯`);
                } else {
                    chatHistory = [];
                    console.log("â„¹ï¸ MongoDB ä¸­æ²¡æœ‰å†å²è®°å½•ï¼Œä½¿ç”¨ç©ºæ•°ç»„");
                }
            } catch (error) {
                console.warn("âŒ ä» MongoDB åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨ localStorage:", error.message);
                chatHistory = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            }
        } else {
            console.log("ğŸ“‚ ä» localStorage åŠ è½½èŠå¤©å†å²...");
            chatHistory = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        }
    }

    // ä¿å­˜èŠå¤©å†å²
    async function saveChatHistory() {
        if (MONGODB_CONFIG.enabled) {
            try {
                await saveToMongoDB(chatHistory);
                console.log("âœ“ å·²ä¿å­˜åˆ° MongoDB");
            } catch (error) {
                console.warn("âŒ ä¿å­˜åˆ° MongoDB å¤±è´¥ï¼Œä½¿ç”¨ localStorage:", error.message);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(chatHistory));
            }
        } else {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(chatHistory));
        }
    }

    // ä» MongoDB è¯»å–æ•°æ®
    async function fetchFromMongoDB() {
        // ä½¿ç”¨ Vercel éƒ¨ç½²çš„åç«¯ API
        const apiUrl = "/api/chat/get";

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                userId: MONGODB_CONFIG.userId
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        return await response.json();
    }

    // ä¿å­˜åˆ° MongoDB
    async function saveToMongoDB(messages) {
        // ä½¿ç”¨ Vercel éƒ¨ç½²çš„åç«¯ API
        const apiUrl = "/api/chat/save";

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                userId: MONGODB_CONFIG.userId,
                messages: messages,
                updatedAt: new Date().toISOString()
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        return await response.json();
    }

    // æ£€æŸ¥å¹¶åˆ—å‡ºå¯ç”¨çš„æ¨¡å‹
    async function checkAvailableModels() {
        console.log("ğŸ” æ£€æŸ¥ API æä¾›å•†çŠ¶æ€...");
        for (let i = 0; i < API_PROVIDERS.length; i++) {
            const provider = API_PROVIDERS[i];
            try {
                const url = `${provider.baseUrl}/models?key=${provider.apiKey}`;
                const response = await fetch(url);
                if (response.ok) {
                    console.log(`âœ“ ${provider.name} - å¯ç”¨`);
                    return; // æ‰¾åˆ°å¯ç”¨çš„å°±é€€å‡º
                } else {
                    console.warn(`âœ— ${provider.name} - çŠ¶æ€ ${response.status}`);
                }
            } catch (error) {
                console.warn(`âœ— ${provider.name} - è¿æ¥å¤±è´¥`);
            }
        }
    }

    // æ£€æµ‹æ˜¯å¦ä¸ºè¡¨æƒ…åŒ…æ¶ˆæ¯
    function isEmojiPackMessage(text) {
        return /^\[bqb-[^\]]+\]$/.test(text.trim());
    }

    // æå–è¡¨æƒ…åŒ…åç§°
    function extractEmojiPackName(text) {
        const match = text.match(/\[bqb-([^\]]+)\]/);
        return match ? match[1] : null;
    }

    // åˆ†ç¦»æ–‡æœ¬å’Œè¡¨æƒ…åŒ…
    function separateTextAndEmoji(text) {
        const parts = [];
        const lines = text.split('\n');
        let textPart = [];

        for (const line of lines) {
            if (/^\[bqb-[^\]]+\]$/.test(line.trim())) {
                // å…ˆæ·»åŠ ä¹‹å‰çš„æ–‡æœ¬
                if (textPart.length > 0) {
                    parts.push({ type: 'text', content: textPart.join('\n') });
                    textPart = [];
                }
                // æ·»åŠ è¡¨æƒ…åŒ…
                parts.push({ type: 'emoji', content: line.trim() });
            } else if (line.trim()) {
                textPart.push(line);
            }
        }

        // æ·»åŠ å‰©ä½™çš„æ–‡æœ¬
        if (textPart.length > 0) {
            parts.push({ type: 'text', content: textPart.join('\n') });
        }

        return parts;
    }

    function addMessageToUI(text, role) {
        // æ£€æŸ¥æ˜¯å¦æ˜¯çº¯è¡¨æƒ…åŒ…æ¶ˆæ¯
        if (isEmojiPackMessage(text)) {
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${role === 'user' ? 'sent' : 'received'}`;

            const emojiName = extractEmojiPackName(text);
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble emoji-pack-bubble';
            bubble.innerHTML = `<span class="emoji-pack-name">${emojiName}</span>`;

            wrapper.appendChild(bubble);
            messagesContainer.appendChild(wrapper);
            return;
        }

        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${role === 'user' ? 'sent' : 'received'}`;

        // æ ¼å¼åŒ–æ–‡æœ¬ï¼Œç§»é™¤å†…è”çš„è¡¨æƒ…åŒ…æ ‡è®°ï¼ˆå¦‚æœæœ‰çš„è¯ï¼Œå•ç‹¬æ˜¾ç¤ºï¼‰
        let formattedText = text
            .replace(/\[bqb-[^\]]+\]/g, '') // ç§»é™¤è¡¨æƒ…åŒ…æ ‡è®°
            .replace(/\n/g, '<br>')
            .replace(/\*(.*?)\*/g, '<span class="narrative-action">* $1 *</span>')
            .trim();

        if (formattedText) {
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';
            bubble.innerHTML = formattedText;
            wrapper.appendChild(bubble);
            messagesContainer.appendChild(wrapper);
        }
    }

    // å¤„ç† AI å›å¤ï¼Œåˆ†ç¦»æ–‡æœ¬å’Œè¡¨æƒ…åŒ…
    function processAIReply(reply) {
        const parts = separateTextAndEmoji(reply);
        return parts;
    }

    function scrollToBottom() {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    async function handleSend() {
        const text = inputEl.value.trim();
        if (!text) return;

        // UI æ›´æ–°
        addMessageToUI(text, 'user');
        inputEl.value = '';
        scrollToBottom();

        // å†å²ä¿å­˜
        chatHistory.push({ role: 'user', content: text });
        await saveChatHistory();

        statusEl.textContent = "Ling is typing...";

        try {
            // è°ƒç”¨ API
            const reply = await callGemini(chatHistory);

            // å¤„ç† AI å›å¤ï¼Œåˆ†ç¦»æ–‡æœ¬å’Œè¡¨æƒ…åŒ…
            const parts = processAIReply(reply);

            // é€ä¸ªæ˜¾ç¤ºæ¶ˆæ¯éƒ¨åˆ†ï¼ˆå¸¦å»¶è¿Ÿæ•ˆæœï¼‰
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];

                if (i > 0) {
                    // è¡¨æƒ…åŒ…æ¶ˆæ¯ç¨åæ˜¾ç¤ºï¼Œæ¨¡æ‹Ÿæ‰“å­—æ•ˆæœ
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                addMessageToUI(part.content, 'assistant');
                scrollToBottom();

                // æ¯ä¸ªéƒ¨åˆ†å•ç‹¬ä¿å­˜åˆ°å†å²è®°å½•
                chatHistory.push({ role: 'assistant', content: part.content });
            }

            await saveChatHistory();
        } catch (e) {
            console.error("Chat Error:", e);
            addMessageToUI(`[Error: ${e.message}. Please try again.]`, 'assistant');
        } finally {
            statusEl.textContent = "";
            scrollToBottom();
        }
    }

    // --- æ™ºèƒ½ API è°ƒç”¨å‡½æ•° (æ”¯æŒå¤šæä¾›å•†è½®è¯¢) ---
    async function callGemini(history) {
        let lastError = null;

        // éå†æ‰€æœ‰ API æä¾›å•†
        for (let i = 0; i < API_PROVIDERS.length; i++) {
            const provider = API_PROVIDERS[i];

            try {
                console.log(`ğŸ”„ å°è¯• ${provider.name}...`);
                const responseText = await fetchFromProvider(provider, history);
                console.log(`âœ“ æˆåŠŸä½¿ç”¨ ${provider.name}`);
                return responseText;
            } catch (error) {
                console.warn(`âœ— ${provider.name} å¤±è´¥:`, error.message);
                lastError = error;

                // å¦‚æœæ˜¯ 429 é”™è¯¯ï¼Œç­‰å¾…åç»§ç»­ä¸‹ä¸€ä¸ªæä¾›å•†
                if (error.message.includes('429')) {
                    console.log(`  é…é¢ç”¨å®Œï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæä¾›å•†...`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªæä¾›å•†
            }
        }

        // æ‰€æœ‰æä¾›å•†éƒ½å¤±è´¥
        const errorMsg = lastError?.message || 'æ‰€æœ‰ API æä¾›å•†éƒ½ä¸å¯ç”¨ï¼Œè¯·ç¨åå†è¯•';
        throw new Error(errorMsg);
    }

    async function fetchFromProvider(provider, history) {
        let url, requestBody, headers;

        // æ ¹æ® API ç±»å‹æ„é€ ä¸åŒçš„è¯·æ±‚
        if (provider.type === 'openai') {
            // OpenAI å…¼å®¹æ ¼å¼ (ç¬¬ä¸‰æ–¹ä»£ç†)
            url = `${provider.baseUrl}/chat/completions`;

            const messages = [
                { role: 'system', content: SYSTEM_PROMPT }
            ];

            history.slice(-10).forEach(msg => {
                messages.push({
                    role: msg.role === 'user' ? 'user' : 'assistant',
                    content: msg.content
                });
            });

            requestBody = {
                model: provider.model,
                messages: messages,
                temperature: 0.9,
                max_tokens: 1000,  // å¢åŠ åˆ° 1000
                top_p: 0.95
            };

            headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${provider.apiKey}`
            };

        } else {
            // Gemini å®˜æ–¹æ ¼å¼
            url = `${provider.baseUrl}/models/${provider.model}:generateContent?key=${provider.apiKey}`;

            const contents = [];

            // ç¬¬ä¸€æ¡ï¼šå°†ç³»ç»Ÿæç¤ºä½œä¸º user æ¶ˆæ¯
            contents.push({
                role: 'user',
                parts: [{ text: SYSTEM_PROMPT + '\n\nUnderstood. I will roleplay as Ling Zhaoye.' }]
            });
            contents.push({
                role: 'model',
                parts: [{ text: 'Understood. I am Ling Zhaoye.' }]
            });

            // æ·»åŠ å¯¹è¯å†å²
            history.slice(-10).forEach(msg => {
                contents.push({
                    role: msg.role === 'user' ? 'user' : 'model',
                    parts: [{ text: msg.content }]
                });
            });

            requestBody = {
                contents: contents,
                generationConfig: {
                    temperature: 0.9,
                    maxOutputTokens: 1000,
                    topP: 0.95,
                    topK: 40
                }
            };

            headers = {
                'Content-Type': 'application/json'
            };
        }

        console.log(`ğŸ“¤ å‘é€è¯·æ±‚åˆ° ${provider.name}:`, requestBody);

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody)
        });

        // æˆåŠŸå“åº”
        if (response.ok) {
            const data = await response.json();
            console.log(`ğŸ“¦ ${provider.name} åŸå§‹å“åº”:`, data);

            // æ ¹æ® provider ç±»å‹è§£æå“åº”
            if (provider.type === 'openai') {
                // OpenAI æ ¼å¼å“åº”
                if (data.choices && Array.isArray(data.choices) && data.choices.length > 0) {
                    console.log("âœ“ è§£æ OpenAI æ ¼å¼å“åº”");
                    const message = data.choices[0].message;
                    const text = message?.content || message?.text;
                    if (text) {
                        console.log(`âœ“ æå–æ–‡æœ¬: ${text.substring(0, 50)}...`);
                        return text;
                    }
                }
            } else {
                // Gemini æ ¼å¼å“åº”
                if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0) {
                    console.log("âœ“ è§£æ Gemini æ ¼å¼å“åº”");
                    const candidate = data.candidates[0];
                    console.log("  å€™é€‰å†…å®¹:", candidate);
                    console.log("  finishReason:", candidate.finishReason);

                    const content = candidate.content;
                    console.log("  content:", content);

                    if (content && content.parts && Array.isArray(content.parts) && content.parts.length > 0) {
                        const text = content.parts[0]?.text;
                        if (text) {
                            console.log(`âœ“ æå–æ–‡æœ¬: ${text.substring(0, 50)}...`);
                            return text;
                        } else {
                            console.error("âŒ parts[0] å­˜åœ¨ä½†æ²¡æœ‰ text å­—æ®µ");
                        }
                    } else {
                        console.error("âŒ content.parts ä¸ºç©ºæˆ–ä¸å­˜åœ¨");
                        console.error("   content:", JSON.stringify(content));

                        // æ£€æŸ¥æ˜¯å¦å› ä¸º MAX_TOKENS å¯¼è‡´ç©ºå“åº”
                        if (candidate.finishReason === 'MAX_TOKENS') {
                            throw new Error('å“åº”è¢«æˆªæ–­ (MAX_TOKENS) - è¯·æ£€æŸ¥è¯·æ±‚æ ¼å¼');
                        }
                    }
                }
            }

            // å¦‚æœéƒ½ä¸æ˜¯ï¼ŒæŠ›å‡ºè¯¦ç»†é”™è¯¯
            console.error("âŒ æ— æ³•è¯†åˆ«çš„å“åº”æ ¼å¼:", JSON.stringify(data, null, 2));
            throw new Error('Invalid response format - æ— æ³•è§£æå“åº”');
        }

        // 400 é”™è¯¯ - API Key æ— æ•ˆ
        if (response.status === 400) {
            throw new Error('API Key æ— æ•ˆ (400)');
        }

        // 429 é…é¢é”™è¯¯
        if (response.status === 429) {
            throw new Error('é…é¢å·²ç”¨å®Œ (429)');
        }

        // å…¶ä»–é”™è¯¯
        const errData = await response.json().catch(() => ({}));
        const errorMessage = errData.error?.message || `HTTP ${response.status}`;
        throw new Error(errorMessage);
    }

    sendBtn.addEventListener('click', handleSend);
    inputEl.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleSend();
    });

    let taps = 0;
    document.getElementById('reset-btn').addEventListener('click', () => {
        taps++;
        if (taps >= 5) {
            if(confirm("Clear chat history?")) {
                localStorage.removeItem(STORAGE_KEY);
                location.reload();
            }
            taps = 0;
        }
    });

    init();
</script>
</body>
</html>
